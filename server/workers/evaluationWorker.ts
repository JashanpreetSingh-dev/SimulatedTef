/**
 * Background worker for processing AI evaluation jobs
 */

import { Worker } from 'bullmq';
import { connection } from '../config/redis';
import { EvaluationJobData, EvaluationJobResult } from '../jobs/jobTypes';
import { geminiService } from '../../services/gemini';
import { resultsService } from '../services/resultsService';
import * as taskService from '../services/taskService';
import { generateTaskId, TaskType } from '../../types/task';
import { SavedResult, OralExpressionData, WrittenExpressionData } from '../../types';
import { closeDB } from '../db/connection';

let worker: Worker<EvaluationJobData, EvaluationJobResult> | null = null;

/**
 * Start the evaluation worker
 */
export function startWorker(): Worker<EvaluationJobData, EvaluationJobResult> {
  if (worker) {
    console.log('Worker already started');
    return worker;
  }

  worker = new Worker<EvaluationJobData, EvaluationJobResult>(
    'evaluation',
    async (job) => {
      const {
        section,
        prompt,
        transcript,
        scenarioId,
        timeLimitSec,
        questionCount,
        userId,
        recordingId,
        mode,
        title,
        taskPartA,
        taskPartB,
        eo2RemainingSeconds,
        fluencyAnalysis,
      } = job.data;

      try {
        // Update job progress
        await job.updateProgress(10); // 10% - Starting

        console.log(`Processing evaluation job ${job.id} for user ${userId}`);

        // Call Gemini API for evaluation (this is the slow part)
        await job.updateProgress(30); // 30% - Processing
        
        const result = await geminiService.evaluateResponse(
          section,
          prompt,
          transcript,
          scenarioId,
          timeLimitSec,
          questionCount,
          mode,
          taskPartA,
          taskPartB,
          eo2RemainingSeconds,
          fluencyAnalysis
        );

        await job.updateProgress(80); // 80% - Evaluation complete

        // Determine resultType and module
        const resultType: 'practice' | 'mockExam' = job.data.mockExamId ? 'mockExam' : 'practice';
        const module: 'oralExpression' | 'writtenExpression' = section === 'OralExpression' ? 'oralExpression' : 'writtenExpression';

        // Save tasks to normalized storage and create references
        const taskReferences: { taskA?: { taskId: string; type: TaskType }; taskB?: { taskId: string; type: TaskType } } = {};
        
        if (taskPartA) {
          const taskAType: TaskType = section === 'OralExpression' ? 'oralA' : 'writtenA';
          const taskAId = generateTaskId(taskAType, taskPartA);
          await taskService.saveTask(taskAType, taskPartA);
          taskReferences.taskA = { taskId: taskAId, type: taskAType };
        }
        
        if (taskPartB) {
          const taskBType: TaskType = section === 'OralExpression' ? 'oralB' : 'writtenB';
          const taskBId = generateTaskId(taskBType, taskPartB);
          await taskService.saveTask(taskBType, taskPartB);
          taskReferences.taskB = { taskId: taskBId, type: taskBType };
        }

        // Build moduleData based on section
        let moduleData: OralExpressionData | WrittenExpressionData;
        
        if (section === 'OralExpression') {
          moduleData = {
            type: 'oralExpression',
            ...(mode === 'partA' || mode === 'full' ? {
              sectionA: {
                text: transcript.split('Section A')[1]?.split('Section B')[0]?.trim() || transcript,
                result: mode === 'partA' ? result : undefined,
              }
            } : {}),
            ...(mode === 'partB' || mode === 'full' ? {
              sectionB: {
                text: transcript.split('Section B')[1]?.trim() || (mode === 'partB' ? transcript : ''),
                result: mode === 'partB' ? result : undefined,
              }
            } : {}),
          };
        } else {
          // WrittenExpression
          moduleData = {
            type: 'writtenExpression',
            ...(mode === 'partA' || mode === 'full' ? {
              sectionA: {
                text: job.data.writtenSectionAText || '',
                result: mode === 'partA' ? result : undefined,
              }
            } : {}),
            ...(mode === 'partB' || mode === 'full' ? {
              sectionB: {
                text: job.data.writtenSectionBText || '',
                result: mode === 'partB' ? result : undefined,
              }
            } : {}),
          };
        }

        // Build the result object with new structure
        const resultToSave: SavedResult = {
          _id: undefined, // Will be generated by MongoDB
          userId,
          resultType,
          mode: mode as 'partA' | 'partB' | 'full',
          module,
          title,
          timestamp: Date.now(),
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          taskReferences,
          evaluation: result,
          moduleData,
          recordingId,
          transcript,
          ...(job.data.mockExamId && { mockExamId: job.data.mockExamId }),
        };

        // Save result to database
        // For mock exams, use upsert to update any existing placeholder instead of creating duplicate
        let savedResult: SavedResult;
        if (job.data.mockExamId) {
          savedResult = await resultsService.upsertMockExamResult(resultToSave);
        } else {
          savedResult = await resultsService.create(resultToSave);
        }

        await job.updateProgress(100); // 100% - Complete

        console.log(`Evaluation job ${job.id} completed, result ID: ${savedResult._id}`);

        // Return result ID
        return {
          resultId: savedResult._id as string,
          success: true,
        };
      } catch (error: any) {
        console.error(`Evaluation job ${job.id} failed:`, error);
        // Job failed - will be retried automatically by BullMQ
        throw error;
      }
    },
    {
      connection: {
        host: connection.host,
        port: connection.port,
        ...(connection.password && { password: connection.password }),
      },
      concurrency: 5, // Process 5 jobs simultaneously
      limiter: {
        max: 10, // Max 10 jobs per
        duration: 1000, // 1 second (rate limiting)
      },
    }
  );

  // Worker event handlers
  worker.on('completed', (job) => {
    console.log(`Job ${job.id} completed successfully`);
  });

  worker.on('failed', (job, err) => {
    console.error(`Job ${job?.id} failed:`, err.message);
  });

  worker.on('error', (err) => {
    console.error('Worker error:', err);
  });

  worker.on('active', (job) => {
    console.log(`Job ${job.id} is now active`);
  });

  console.log('Evaluation worker started');

  return worker;
}

/**
 * Stop the evaluation worker gracefully
 */
export async function stopWorker(): Promise<void> {
  if (worker) {
    console.log('Stopping evaluation worker...');
    await worker.close();
    worker = null;
    console.log('Evaluation worker stopped');
  }
  // Close database connection
  await closeDB();
}

// If this file is run directly, start the worker
if (import.meta.url === `file://${process.argv[1]}`) {
  startWorker();
  
  // Graceful shutdown
  process.on('SIGTERM', async () => {
    await stopWorker();
    process.exit(0);
  });

  process.on('SIGINT', async () => {
    await stopWorker();
    process.exit(0);
  });
}

